/* ToDo
-------
shared.family (forces all to subscribe)
mask shared.systme on react?
Cloning tasks
  Run the init phase with the initial configuration, then coordinate update
    How to know when the init is done, what about early messages etc ?
      If the task has a state then wait until start state has been run
        Can detect this on the processor and signal to Hub: initDone
          Pause the Task until updated (e.g. block UI events - loading page)
            How does React know the Start is finished - it will see the SM update
Restoring of a previous family (so could review conversations)
  List all conversations (query MongoDB)
  Copy of an active conversation
    Does this imply copying a family set?
    How to load tasks ? From the UI
    React will try to spawn tasks
      Allow start to pass an instance ID then restore instead of creating
  Ability to navigate through the history ?
    Risk of an intermediate state
      Could specify which states can be restored ? e.g. input for chat

Note that adding a domain should also disable the CloudFlare caching
TaskRAGAdmin
  Choose a corpus, restart, prepare, upload, delete
  Remove elements from cache
How to add UI elements to existing Task ?
  Could have a pre-post component slot that the HoC can insert and pass the parent task down as prop
    task down task.inputs (writable) and task.outputs (readable)
  Just create new TaskRAGChat based on TaskChat
Managing secrets https://hub.docker.com/r/hashicorp/vault
In a post config step transfer config.local into config ?
Need separate threads for data processing - ability to detach a task as a separate process
  Task could launch worker_threads
  Multiple processors could share a queue
Cron to allow TaskStatus
  TaskSystemCron where we can register cron jobs
  https://github.com/harrisiirak/cron-parser
  It could send an update command with args indicating it is a cron job
Share the caching of services/operators across tasks (will make copy easier)
OpenAI features: JSON mode, parallel function calls 
Cookie could encode array of tribes
  Problem if user is not unique
    Should just enforce unique users
Support for children 
  Use tasktypes instead
config.local -> config.self ?    
Version table in accessdb
  version.current
  Create a new table with new schema, copy data into it, delete old table, rename new table (all in a transaction)
    First time will be to add the version table
  Could do something similar for config (version in dir path)
    Need to "rewrite" nicely
  Could also have similar approach for tasks
    Processor registers task version
      Hub maps (requires going in both directions)
With task.node.command we can have parallel commands from different processors
Review for security holes
  commandArgs.authenticate
  sharedEntry["system"]
When registering the Hub should provide the app info : 
  appAbbrev is used in the Node id of React for storage
    could connect after registering ?
Move runDumpOneConfigScript from storage to configdata
TaskMe - Editing of personal info
Could use hierarchy for different sets of users/groups
When user is removed from group the group is not updated
  We should treat users+groups as one type?
  Do not need to load groups if we load users
  Should still load users before groups in the case of loading groups? (see storage)
  Allow for first/last name in Users
  Dynamic modification of users/groups might be better with a separate user<->groups and users<->group mapping
    But this is another data structure ?
    Groups could use hierarchy
    Could abstract into a function that operates on both users and groups
    Replace with authorization
Loading indicator in Taskflow.js
Use the runtime config to add admin-dtf to permisssion of root.system.
Option to delete cache responses (also indicate them)
Add a redirect command so we can redirect user after they are removed (can't redirect from websocket)
Callbacks that error are not caught in try/catch e.g. sqlite3 library
Add Frontend for TaskRAGProcessing - to indicate progress/done, just needs to display the state
  Could experiment with a progress meter via websocket
To allow task config to be modified during init via connections we need to run CEPConnect on the Coprocessor
  Could use .shared ? No that still requires modifying the Task to use shared instad of its config
Services should still use the Task schema (command) by preference?
Disk space on server1
Not cleaning up connectionsStore_async
  Remove when deleting activeTask (we manage family already?)
Create Service for embeddings
  Also SendIncrementalWs
Security
  https://deno.com/ instead of nodejs
  Protecting keys
    https://github.com/KenyonY/openai-forward
    https://docs.litellm.ai/docs/proxy_server can b used as a proxy and I got this running with ollama
Local LLM
  https://github.com/mudler/LocalAI 
    Followed https://localai.io/basics/getting_started/#example-use-luna-ai-llama2-model-with-docker-compose
    The llama model output german junk
    Seems very heavy with many things installe dinto the Docker container
  https://ollama.ai/
    https://hub.docker.com/r/ollama/ollama
      docker run -d -v ollama:/root/.ollama -p 127.0.0.1:11434:11434 --name ollama ollama/ollama
      List models: curl http://localhost:11434/api/tags
      Install model: curl -X POST http://localhost:11434/api/pull -d '{ "name": "mistral" }'
      Query:
      curl -X POST http://localhost:11434/api/generate -d '{
        "model": "mistral",
        "prompt":"Here is a story about llamas eating grass"
      }'
      Connect to bash: docker exec -it ollama /bin/bash
       Then can run CLI chat: ollama run mistral:instruct
  https://docs.litellm.ai/docs/proxy_server
    git clone https://github.com/BerriAI/litellm.git
    cd litellm
    cp ./router_config_template.yaml ./config.yaml
    vi ./config.yaml
      Modify for Mistral api_base: 127.0.0.1:11434
    docker build -t litellm_server . --build-arg CONFIG_FILE=./router_config.yaml
    docker run --name litellm_server -e PORT=8000 -p 127.0.0.1:8000:8000 litellm_server
    curl -X POST localhost:8000/v1/chat/completions \
      -H 'Content-Type: application/json' \
      -d '{
        "model": "mistral",
        "messages": [{
          "content": "Hello, how are you?",
          "role": "user"
        }]
      }'
    I created docker-compose.yaml with litellm_server and added in the ollama service (but need to install model with curl -X POST http://localhost:11434/api/pull -d '{ "name": "mistral" }')
    baseURL: `http://litellm_server:8000`
    See /root/litellm on server1
    Still quite slow, maybe RWKV would be possible
Experiment with huggingface
  The models do not have drop-in replacement for OpenAI
  Pro account has an inherent cap on API usage
  Maybe we could put this behind liteLLM?  Yes
    https://github.com/BerriAI/litellm/issues/361#issuecomment-1722350013
Could keep historyContext on the processor
Notebook for analysing data
  A task could be a Notebook
    Can we use Javacsript+Python
  https://observablehq.com/cloud hosted
  https://polynote.org 
  https://github.com/ipyflow/ipyflow
  Should be able to load the task as JSON
    How to access the Node API ?
  Jupyter has an API so we can create a notebook on the fly and populate it.
  https://docs.deno.com/runtime/manual/tools/jupyter
    Could be a way to experiment with Deno
  https://github.com/yunabe/tslab
  https://github.com/yunabe/tslab
  Two separate Tasks - edit+execute and execute
  The execute task would run the notebook and just get back the task (maybe using REST API or just launch)
  The edit task would run the current task in browser but would need a mechanism to send the task back to the server at the end.  
Use a function to update task then we can trace this
 T(task, "input.test")
 T(task, "input.test", "new value")
 Or we create a function instead of task and pass that
Replace throw with devThrow 
Task object are getting very big ?
  Storing origTask for node on hub ?
Why is CEPConnect SEP of : not working?
  Specific to key starting with :
https://cookbook.openai.com/examples/clustering clustering 
  Could experiment with ART for hierarchical clustering
    Create up to N categories
     If the input mathcs with a category but id more distant than the most distant category pair then create a new category and merge the closest two categories.
     Could reduce N but on what basis ?
Completion end point gpt-3.5-turbo-instruct is compatible with the "old" style API
Styles of data processing
  What are the main insights ? Meta questions.
  Educational format
Experiment with Apify for web scraping
Refactoring
  Should we only use task.command instead of task.node.command ?
    Avoids needing to copy it, seems reasonable
  The processor should also have a local task.nodes (so it can support multiple hubs)
    First (common) step is to copy task.node into task.nodes
  Align similar modules on the hub and rxjs
    Softlink to use rxjs src from hub/src/rxjs-src 
    Could pull out common functions
  Naming convention is confused for e.g. commandUpdate
    On the hub commandUpdate processes an update task
      processUpdate ?
    On rxjs commandUpdate generates an update task
  Should disintguish between requesting to register and register
    Or does the hub register with the nodes and then inverse
    So not really a request it is just that the node responds by also Registering
  Unique to the hub:
    taskConverterWrapper.mjs 
      fromTask is used
      Rework as explicit validation
    validateTasks.mjs
      Rename to validateConfigTasks.mjs
    config of tasks, tasktypes, users, groups
    commandError.mjs
    commandInit.mjs
    commandStart.mjs
    commandUpdate.mjs (different)
    commandRegister.mjs (different)
    configdata.mjs
      Close to how we need to treat operators/services/CEPs
    storage 
      Identify the differences in export
    taskProcess.mjs -> nodeTasks.mjs
    taskStart.mjs
    taskSync.mjs
    webSocket.js
    server.js
Updates on rxjs need to block, like on react
  Update needs to hold the lock until the update returns for storage to update
    Allows for CEP to operate but slow
    Could only error if there is a hash mismatch AND the values do not match
Document sync behavior
  Can the sync interfere with hash diff ? No
    We do not use the hashDiff for sync
  sync will not run task function so menu will not be updated
    Created an option syncUpdate that applies a normal update
FSM is remounted in previous state
  So unmount in the state we want to restart from - not ideal
  Could have "state.initial" that would allow for control over this when reloading a Task
In Firefox mobile need to move the Toolbar to the Top so it does not hide content at the bottom of the page 
TaskRx could be an example of a task only on processor-consumer
  Add command protocol
  PythonRunner should be a Service
  
Demo of copying a task
  Copy of TaskChat
    System task that starts a conversation 
      During start provide commandArgs with copyId
        Could intercept with CEP so TaskConversation is unchanged
          TaskCopy
            Does it need to be specific to TaskConversation ?
              config would map id to particular instanceId for copying
                only copy the TaskChat
                  TaskCopy could be configured for particular child (conversation)
                    Point to familyId so TaskCopy can find the Tasks to copy?
    Review taskStart to identify what must be replaced in the copy
      set commandArgs.copyInstanceId and then copy task to initTask 
      children/parent (as per pasteBranch_async)
      familyId
tasksStore_async -> taskconfigsStore_async
  tasks.mjs -> taskconfigs.mjs
Test Docker setup
Random Client is broken
Check Demo of collaborative chat
Keep both autoStartEnvironments and autoStartEnvironments ?
Major features to implement before further refactoring
  Running Python scripts
  Debug support per Task
    Explore more about import debug from "debug"; 
  TaskCreateTask
    Identify closest existing task (vectorDB for task descriptions)
      Chat interaction
        Validation/ESlint
          Testing
    Dynamic Task as per dynamic config
      Needs to modify tasktypes (another Task)
        TaskDynamic that is on every processor ?
          Allows tasks to be created on the fly
            Can overwrite the type but this really is just dynamic config
              What about new Task Function ?
                Write out new modules from Processor ?
                Eval of code in the config
                Introspection
Masking at least for React seems important
If CEP then fsm -> FSM
Much of "services.chat" should be in "operators.LLM" ?
  At least that which is used in OperatorLLM.mjs
tasksSchema should be part of a service?
  Could have a logging service regarding internal behavior of nodes
Merge hub with rxjs
  Globally replace processorId with nodeId
  Move rxjs to configdata.mjs
We need to be able to edit/resubmit in the chat to explore prompts
  Could start with an option to delete
    Could replace content with empty string.
Support both web socket and RxjS queue
  Abstract interface that is configured via node configuration
  These can be different subjects in rxjs
    TaskSync sends to event queue or websocket
      node registers as event based or websocket
Total token count for conversation (using what chatGPT returns - usage)
A Processor that is restarted does not rejoin the activeTasks ?
tasktype cannot configure fsm: { useMachine: true} ?
The stepper sets the state to exit - it should not act directly on the state, use task.input
  Review all Tasks and ensure not accessing internals of children
TaskChat name must be "start" ? 
Need to clean up when tasks stop e.g rxjs-processor-consumer activeTaskFsm
Automatic Response Repair
  https://community.openai.com/t/functions-half-a-solution-to-getting-structured-responses-from-gpt/282096
  The key points are
    the api you call with the json provided by ai must be written in a way that does a full validation of the input and return as json a payload that state exactly what is wrong and what action the ai should take to fix it .
    Pass this json to ai as a function message and it will setup for the user a message stating what is missing / wrong , so that the user can act accordingly. (Of course you must send the whole ongoing conversation to ai ) .

    These models have been tuned to follow instructions, so you need to tell the model the exact change you want it to make. If the function is missing a “foo” parameter don’t tell it “you forgot a parameter named ‘foo’” instead instruct it to “add a ‘foo’ parameter”.
    https://github.com/Stevenic/alphawave
      https://medium.com/@ickman/making-openai-functions-reliable-dc206181afc9
https://en.wikipedia.org/wiki/Barbara_J._Grosz

Add the user object only if it has changed
  If the task is collaborative then the user should be associated with task.node?
    Then would not need to send all the time
      Could have multple users on the the same processor collaborating
Switch from hub/processor to node
  Add support for multiple hubs (i.e. bridge)
    Will allow fro bridge between TF & MTF
  Tasks dedicated to processor is another reason to have a single "node"
  Move to task.node ?
  One the hub we copy task.node into task.nodes then setup task.node
Menu should not have shared.configTreeHubconsumerTasks on React
  Could store processor specific info in task.node
    But it is using task.shared
    Masking could fix this
Could have an option on CEP as to whether we need to await or not
  Would allow for concurrent processing for most CEP
  Those that can be run concurrently might be better in a particular class of processor
Need to think more about locks for tasks initiated on hub (start/update/error)
Verbosity level for debug
TaskSystemDebug
  Modifies a task by sending sync
    Can also match on id
    Can it use a try catch and eval the debug filter - so no need to reload?
    The util.debugTask function can be modifed in the browser/server by the Task ?
      Need a JS editor in the task
task.familyId should be in meta?
Avoid using the "start" task name/id as meaningful
TaskSystemConfigTasks_async copy feature in tree
    Request/response could be for a service while input/output is for a taskFunctions
      Maybe input/output is sequential while request/response can be queued
        Seems like a good use case to create the request/response queue
    Refactor SystemTasksConfigEditor so it uses SystemTasksConfig
Task to inspect the Task Node
  Access to KeyV
    Shared can include a list of the available Nodes
    Selecting Node would populate the list of available KeyV
    Selecting KeyV will open table
      Also provide stats
    Base it on TaskSystemLogViewer
      Add dropdown to choose the KeyV store
        Does KeyV provide any features?
    use Keyv.options API to get the namespace and type of store
  Redis search
    To use these features, you must install two modules: RedisJSON and RediSearch. Redis Stack automatically includes both modules.
    https://github.com/redis/node-redis/tree/master/packages/search
  Serious problem is that keyv will not know how to make use of RedisJSON ?
    Could extend https://github.com/jaredwray/keyv/tree/main/packages/redis with https://github.com/schulzf/ioredis-rejson
    https://github.com/redis/ioredis/blob/main/examples/module.js can use any Redis command
      https://joeywhelan.blogspot.com/2022/10/redisearch-ioredis-client-lib.html demo
      https://github.com/Redislabs-Solution-Architects/ioredis-search/tree/main code of demo
  To begin with we could avoid providing search
    Allow for lookup, provide stats
In the coprocessing of task if we remove null then we lose the delete
  If we don't remove null then coprocessing task need to deal with null (e.g. when looping over object keys)
  Processor could detect null keys and create a "delete" object
How can we detect errors in the console?
  window.onerror
  window.addEventListener('unhandledrejection'
  Can also override console.log console.error (before they are used)
    Could create a window.log that meta can access as a feature of the React Processor
Could configure CEP to run during or after coprocessing
Registering could/should be a task
  use the nodeId as an instanceId
How do we drive the input of another task without UI ?
  New command 
    "input" which drives local task
      Use this instead of sync in TaskSystemTasksConfigEditor
      How to implement on React? 
        Through globalContext ? 
          A taskContext with a selector based on instanceId
Create a TaskSystemContainer on React that will do most of what Taskflows.js does
  Then we can configure it
  Should not have a familyId ? (allowing children to create their own)
  Taskflows.js should be a task then would have task.user available and could remove globalState.user
Janssen Project for login
Ant Design
  https://developer.okta.com/blog/2020/09/16/ant-design-react-app
  https://ant.design/theme-editor
  https://github.com/ant-design/ant-design
Made a request to https://pro.reactflow.dev for flowchart GUI
Redis  
  A secondary index maps each attribute to a set of primary keys that have that attribute. 
  In Redis, you need to create a Redis Search index on your data before you can query it.
  Write-behind caching
  @keyv/tiered could offer JSON search via MongoDB ? Yes but V5 will have tiered as a feature
PM2 for process management
  Ecosystem File
  pm2 startup (on boot ?)
  Just use to run two instance of RxJS for now.
Collaborate will keep info in the caches and db. How can we clear out a specific familyId ?
  Could prefix the family ID for collaboration with a unique hub ID
    Could use hub Id if it were not stored
      A Task ? But Task Function does not have access. 
        Delete command with argument for familyId 
Point to private extensions of config rather than redirecting the entire config directory
Extend testing
  Batch testing
    TaskCron to regularly check things
    TaskGit to get local status of repo
  https://testing-library.com/docs/react-testing-library/intro/
  How to batch tests?
    TaskSystemBatch that would modify TaskTest config fsm on the fly
    Could build an array of FSM then run through that.
One approach to code review:
  1) Create a new github repo that has an empty master branch
  2) Archive the code to be reviewed: git archive --format=tar --output=../empty-repo/repo.tar HEAD
  3) Create a new branch in the empty repo: git checkout -b review-branch
  4) Untar the archive in the empty repo: tar -xvf repo.tar
  5) Add the files and push: git add .;git push --set-upstream origin review-branch
  6) Open a PR on github so any file can be reviewed
  The above should be doable inside a single repo - create branch delete everything, create another branch from that and add everything at once
Add xstate-viz server path on proxy and choose port

https://opencollective.com/
How to report pass/fail ?
  Dev header with info 
Deleting of tasks for CEP

https://en.wikipedia.org/wiki/Shared-nothing_architecture
  One alternative architecture is shared everything
Task that monitors a collaborative discussion and via another route allows interaction with any one of the persona
  Requires making a temporary copy of the task - could have it as a child then create a holder and copy the relevant data across
  Does not require extending the server ?
    Security flaw for now - a user can "fake" another task (but need the familyId)
Notion of an input pipeline and output pipeline, managed by Processor
  task.config.inputPipeline = [...]
  task.config.outputPipeline = [...]
  task.config.pipeline - then task is called for both input and output
    Need to implement a queue on the task request/response ? The are no longer internal requests
    A new "request" and "response" command then the Processor can implement a queue (provide next request after previous response)
  In React the output bypasses the task but we could do something similar whereby the HoC passes the component output through the output pipeline. Could replace output.
task.id -> task.config.id
  Then task.id could replace task.instanceId
Do we want to be able to configure CEP functionality?
  The Task provides state machine not CEP.
  Arguments allow for dynamic CEP function, if the CEP evals e.g., vm2, Jailed, Secure ECMAScript, Function(), AST limiting
    New command "execute" that would just pull active task out of storage
      CEP decides if the Task SM needs to be run
      The Update on the Hub could decide whether to bring the task back to life
        How can this be done on React ?
          Behavior in the case when an init task is received but there is no parent on the processor
    See Processor README.md for mathjs etc
Dynamic task configuration
  Maybe this does not require any new functionality on the hub - just copy from one child task to another
    TaskInherit would be a CEP that catches the start of a task and reconfigures it on the coprocessor before it is launched?
  Raises issues for masking - could just not mask the things we want to be able to modify
    Then allow for copying rather than creating
RxJS V7 Processor
  Experiment with CEP that starts a task e.g. TaskPopup (or maybe an option to TaskShowInstruction)
A scheduler should be able to provide a cron like feature
  TaskCron
    Or can any task do this just by waiting ?
    Seems nice to be able to have  CEP that "wakes" up
    Maybe a JS library can help e.g. an array of cron times
    Maintain an array of jobs and calculate the wait time in a loop for the next wakeup
  TaskCount
    Like a cron but based on the number of interactions
      When task entry X reaches Y then send request A to task B
After experimenting with RxJS processor we may want to use a similar approach in React Processor
  Run RxJS in on the Shared Worker
    Eventually use this instead of lifting state
nextTaskTemplate which allows for re-ordering flow
  replaced with XState? Could pull out this functionality? (the exercises use it I think)
Add schemas for task.config.local as per tasktypes.mjs and use this to check tasks in configdata
  Schema for tasktype to document options
The React Processor provides a parent-child relationship for interaction. How to provide this on Node JS Processor?
  Should enforce the use of taskUpdate instead of driving children
    Could remove the idea of a child task from React
Should the servicetype be copied into task.config.services?
  The servicetype is on the Processor while config is on the Hub
Should the Processor also implement rate limiting?
Ability to select a service type. This is a very simple task?
  Could allow for various ways of selecting. 
If a task is no longer in an environment then shut it down
  Would require something like a delete command sent to nodes
Need to run CEP on local processor to get real-time behavior
  No rush to implement this
The cache is not going to allow a conversation if it matches and the key is not including the messages
In templating maybe we should support "task." syntax
Tests will allow for better code generation
Requests from other tasks via: task.node.task.request
  See notes
If we have a TaskFilter this raises the question of how to configure/program it.
  Detects an event and passes information.
    Filter -> action
      Action is to update another task ?
        How to inform another task
        If we do want a DSL the Lua might be a good option for language indepedence
          https://github.com/fengari-lua/fengari-web
Provide sample of nginx proxy config
log not working in Chrome ?
Make some basic commands available in the console (add function to window)
  Set the userId
Standard for asynchronous APIs 
  https://www.asyncapi.com/ (standard)
Demo of collaborative chat would be good.
  In default config assign a random user label so we can demo multiparty chat
Add function to remove last paragraph
  Interesting to explore how that might be generalized
Privacy - should be implemented on the Hub
  Hub and Processors secure communication, then identification is managed on the hub.
Embedding functions in the template?
  Where/how to manage variables? 
    Lookup only the required tasks not the whole thread.
  What about use across languages?
    Logic-less might be better: Handlebars
Harmonise the Processor
  The infrastructure provided by the Processor should perform the updates to the Task object as this allows for services to be provided upon value changes.
  In React withTask HOC and useTask state.
  A common JS module for managing the Task object. 
    What is generic to Processors and what is custom?
      React Processor adds the concept of address/location.
If we prefix a T on Task parameters it would be easier to update with search & replace
  Better to use full path even in JXS e.g. task.name not name e.g in taskflows and stepper
How can we specify the UI in a more compact/easy way?
  https://github.com/rjsf-team/react-jsonschema-form
  A hook-based solution with minimal boilerplate: React Hook Form
How to have a task deal with compound react components
  config: list of components (with names) for display&input, mapping inputs to request.name.inputs
  config: list of components (with names) for display, mapping to response.name.outputs (if it is displaying a return)
  Basic pattern is: display -> input -> display -> input (can choose to use a subset)
  Could associate components with state of the Task ?
         * -> list of components that are active all the time
    state1 -> list of active components
    state2 -> list of active components
Consider how we would add a radio select box to a component
  Add the component and a config option to display or not
  Dynamic mapping of config to the input
  Standard way of mapping this to response. Make these available as variable in next Task (or state?)
  Could have an inject command from Hub
    Modify the parent task.meta.children and modify the child task.parent etc. then 
      Modify parent should then start new child that can be configured to start previous child as its child
Option to IGNORE config options from parents
  Avoids inheriting info that is not used.
  Can just set to null to achieve this?

Backlog
-------

  Bugs
  -----
  Scrolling to view suggested_prompts in TaskChat
  chatContainermaxHeight in TaskConversation scrolling

  Refactoring
  -----------
  children -> meta.children (used for tree)
  Align usage of utils

  Features
  --------
    High Priority
    -------------
    Possible next feature: remembering the system messages for Vierge
    Simplify multiple configuration files for the NodeJS Processor
    Use a route for configuring: user, session, taskflow, task
    Create a new route for the Client side user defaults. Manage in a global state. Send on all requests.
    Msgs could be loaded from the NodeJS Processor. Similar to stepper - both have history.
    Utility filters e.g. remove outer quotes, an ordered list (use a standard templating library - ejs)
    When user interacts reset the counter to try to establish websocket on client

    Low Priority
    ------------
    Show websocket connection status with traffic light icon
    Could be valuable to communicate with an instance on a subset of environments
    Ability to force a task to restart (Hub command?) Could be a forget button.
      A new conversation button once we have the session restoring.
    Modify the partial text update so it is incremental. This will better allow for text selection.
      Something like react-markdown with the gfm plugin for things like tables but you will need to do some extra work to get the code blocks styled exactly how you are wanting
    Time in oneFamily messages should be aligned with browser timezone (needs to be filled in by Hub?)
    Logout option (could just be a route)
    Sending diff to Hub from Processor during update
    JWT connection between Hub and Processors (currently rely on Cloudflare)
    Move to TypeScript
    Way for tasks to register websocket event handlers
    Multiple language support 'i18next-http-middleware for NodeJS Processor and react-i18next for React Processor
    Defensive programming + logging
    Websocket for tasks (so NodeJS Processor can drive) just send incremental info for the task
    Replace globalState with Redux
    When sending task instance only send diff (React Processor keeps NodeJS Processor copy, NodeJS Processor keeps React Processor copy)
    Add task type validation to websocket
    Only display menu option if leaf is a real task
    Check '.' is not used in keys or it breaks setNestedProperties (test if the JSON schema is now doing this)

  Tasks
  ----------
    MyAssistant -> MyAssistantConversation
    Multiple-choice above prompt to allow for quick refining of prompt e.g. use tutoiment, friendly, formal etc
    Templating with user defined variables
    Assistant to help understanding a problem rather than solving the problem
      Gamification to make learning more engaging
      An assistant to help explaining what the problem is
    Research assistant
    Refactoring assistant (provide a duplicate code environment as the Environment)
      Example of the refactoring provided.
      LLM to explain the refactoring
      LLM to identify which files should be refactored
      Apply refactoring
        Syntax check as code is produced? 
        Fix for syntax errors
    Fetch prompt suggestion
    Integrate https://rapidapi.com/products/api-hub/
    AI powered journal

Notes/Idea
-----
  Asking the service to output in a format that would pass a test might be a good way of constraining prompts
    e.g. provide Python/JS code that the output should pass (e.g. a single word)
  How to interface with other apps with output from T@skFlow ?
    Windows accessibility APIs, such as UI Automation or MSAA (Microsoft Active Accessibility)
  Things will be integrated into existing clients (e.g. email)
  Educate the users to make use of the system
  Writing the Hub and a generic Porcessor in Rust
  No easy way to do this with React in the functional style
    In the future we could build components on the fly
  Could have a task.family entry which allows for broadcast and config
  Hub could look after converting "family" command into instance command
  Task search feature could be a micro-service provided by the Hub?
    For example user can search personal history
  Tools T@skFLow could leverage:
    https://github.com/PrefectHQ/marvin 
      a batteries-included library for building AI-powered software. 
      Marvin's job is to integrate AI directly into your codebase by making it look and feel like any other function.
  Swagger for the API ?
  Refactoring with jscodeshift, see example in config repository
  Should a task that requests to start a Task also be updated by the Hub?
  A GraphQL based API into the Task family may be a useful abstraction that can be offloaded to a Coprocessor
  Stately Studio
    We will be building visual tooling for not just managing actor logic (state machines & statecharts) but also visualization of entire actor systems (architecture diagrams) and the communication between actors (sequence diagrams). This will be a huge step forward for visually understanding and debugging complex systems, and we’re excited to share more about this in the future.
  Work directly with the XState JSON configuration and provide CRUD operation in Javascript
    Layer of CRUD operation on JSON
        Layer of FSM CRUD operations on top
        Consider the objects Lucy supports
      Very simple parser to go from text to Javascript functions using PEG.js
      CREATE_MACHINE(id, initialState): Creates a new state machine.
      ADD_STATE(machineId, stateName, stateBehavior): Adds a new state to an existing machine.
      REMOVE_STATE(machineId, stateName): Removes a state from a machine.
      ADD_TRANSITION(machineId, sourceState, targetState, eventName): Adds a transition from one state to another on an event.
      REMOVE_TRANSITION(machineId, sourceState, eventName): Removes a transition from a state.
      UPDATE_STATE(machineId, stateName, newStateBehavior): Updates the behavior of a state. This could involve adding or removing transitions, or updating effects.
      GET_STATE(machineId, stateName): Retrieves the configuration of a state.
  https://github.com/Starcounter-Jack/JSON-Patch could replace the diff method for sending Tasks JSON Patch is defined by RFC 6902

Architecture
------------
  How to manage multiple interfaces for a Task
      Sub-directory with sub-components and a style or theme
  Tasks can be thought of as something like plugins, maybe there are patterns in that sort of software
      Implies catalog, installation, activation, configuration, updates, permissions, resource limits
      Requires a documented API, the basic principles at the moment:
          Use the Task object to pass information
          Manage task specific storage (e.g. files, user specific data) independently of the NodeJS Processor Stores
  User defaults, taskflow defaults etc can be tasks
  Could add middleware that tasks can use to modify input/output (similar to LangChain)
    Currently in the TaskFunction but should be easy to factor out when that makes sense
      Could allow for a chain of Operators/Services/CEP
  How to call out to Python from the Task function (better to create a Python Task and have the NodeJS Processor provide the environment?)
    "child process execution" with child_process library
    RabbitMQ for message passing good for a local service but do we need high speed, probably not.
    REST API would allow for remote etc, maybe better
    AMQP or MQTT would be more scalable.
  Keep server on rxjs-processor-consumer processor - yes but for debug/admin/metrics etc
    Performance, utilization etc, a Processor Object for this (instead of Task)
    The debug features can be shared between nodes e.g. just connect to keyv with activeTasks
  Re-architect the react Processor to make use of the Service Worker API
    Should have React Hub
    Progressive Web Apps https://developer.chrome.com/docs/workbox/
    ServiceWorker will intercept any HTTP request from a client except WebSocket upgrade requests
    Workbox is built into Create React App (CRA) with a default configuration that precaches all the static assets.
      "react-scripts": "5.0.1"
    Redux State Sync might provide many of these benefits
      Have one tab that is "master" and others as slaves that pass requests to master.
      https://www.howtogeek.com/devops/how-to-sync-a-redux-store-across-browser-tabs/
      This is a different architecture in that all tabs communicate with the server and Redux is synchronized
    Could detect when more than one tab is open then route websocket from one master tab to shared worker then on to slave tabs
      https://github.com/pubkey/broadcast-channel seems good - it provides LeaderElection
      Basically the leader broadcasts what it receives on websocket and forwards what it received on the channel
        The websocket context just needs to decide which to use (depending on whether it is the leader)
        It seems OK to let the HTTP requests go through, eventaully the session could be managed by the Processor
          Then just use the thread to allow different tabs to have the same task
  Ideally we want the same code for Task storage on Hub/React/NodeJs
    https://github.com/jaredwray/keyv/issues/868 V5 is intended to add browser support, also metadata
  https://react.minchat.io/ is one option for chat components

Issues
------
  Tasks run with full NodeJS Processor rights. They should be sandboxed on the NodeJS Processor.
    TaskFunction could run in a docker container
    Each TaskFunction could be a user on Linux
        User could run in a restricted environment e.g. firejail, bubblewrap
        Difficult to stop information being shared across tasks
        Also separate by session
        How to control what information a Task can request from other tasks
          Currently limited to thread
          Should not be able to go "up" the Task hierarchy (only explore current branch)
          Can only read outputs
  Administation/monitoring of T@skFlow, could ping a service that alerts to problems

Comparison with similar systems
----------------------------
  LangChain - a framework for developing applications powered by language models.
    An abstraction above JS and Python
    Standard interface to models (could reuse this)
    service output parsing sytem (could reuse this from TaskFunction)
    Provides stores for custom data e.g. text splitter
    The taskflow in T@skFlow is like an Agent in LangChain
  GPT-Index
    Should leverage this
  Open-AI Plugins
    This is LLM centric and will allow something similar
  Auto-GPT
    https://github.com/Significant-Gravitas/Auto-GPT
    This might be the close but their focus on autonomy is quite different
  https://github.com/modal-labs/quillman
    A complete audio chat app. Meant to serve as a starting point for your own language model-based apps.
  https://gradio.app/
    It would ideally be easy to use a Gradio component
    Embed in an iFrame
  Algovera
    Not open sourced (yet)
    Langchain as backend
    Text as primary interface for specifying taskflows
    Taskflow as first class object
  https://dust.tt/
    Chaining, version control, connections
  https://www.multi.tech/ (MultiFlow)
    taskflows powered by generative models
  https://www.kubeflow.org/
    Making deployments of machine learning (ML) taskflows on Kubernetes simple, portable and scalable.
  https://n8n.io/
    This is very close to what I want
    But n8n is fair-code distributed under the Sustainable Use License and the n8n Enterprise License.
    Commercially restricted by its authors
    This led me to Node-RED
  https://nodered.org/
  Meteor
     Meteor's data synchronization mechanism known as Distributed Data Protocol (DDP).
     Messages: DDP uses a small set of message types to communicate data changes, including added, changed, removed, ready, nosub, result, updated, and more. 
  https://github.com/ParisNeo/lollms-webui
    This project aims to provide a user-friendly interface to access and utilize various LLM models for a wide range of tasks. Whether you need help with writing, coding, organizing data, generating images, or seeking answers to your questions, LoLLMS WebUI has got you covered.
  Resarch Assistants
    Elicit
    ResearchAIde 
    wizdom.ai
    Iris.ai
  https://www.socialagi.dev/
  Apache Flink
  https://github.com/stanfordnlp/dspy
    DSPy unifies techniques for prompting and fine-tuning LMs — and approaches for reasoning and augmentation with retrieval and tools. All of these are expressed through modules that compose and learn.
  https://github.com/guidance-ai/guidance
    Guidance programs allow you to interleave generation, prompting, and logical control into a single continuous flow
  https://lmql.ai/
    LMQL is a programming language for language model interaction
  https://github.com/Stevenic/alphawave
    State-of-the-art response repair logic.


Test Plan
---------
Prefill tasks so we can work on a specifc part of the sequence.
If we stub the services and use a test task for monitoring behavior in the browser then we could have system tests.
Need to look more into testing React apps
Testing should be a task

Features that are manually tested
---------------------------------
  Features:
    general
      mobile XX
        screen rotation XX
      permissions X
      authentication X
      user
        name X
        profile X
        interface X
    menu
      user specific X
      labels XX
      mobile menu closes after select XX
    Tasks
      TaskStepper
        next XX
        back XX
        skip back XX
        expand multiple XX
        close step XX
        scrolling XX
      TaskChoose
        error
      TaskLLMIO
        input
          word count XX
        response
          word count XX
      TaskShowInstruction
        error XX
      TaskChat
      TaskConversation
        scrolling (stop the bouncing) X
        agent specific
          dyad X
          forget 
        task specific
          config 
            messagesTemplate X
            promptTemplate X
            suggestedPrompts X
            welcomeMessage X
            nextTask X
            instruction X
            nextStates X
            oneFamily X
            label X
            reentering
          request
            inputLabel 
            prompt X
            forget X
            agent X
            service X
          response
            userInput X
            text X
          service
            langModel X
            temperature X
            maxTokens X
            maxResponseTokens X
          error X
          errorTask X To test this uncomment line before return in Task/TaskLLMIO.mjs